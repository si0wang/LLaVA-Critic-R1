import argparse
import torch
import os
import json
from tqdm import tqdm
import shortuuid
from transformers import AutoProcessor
from PIL import Image
import math
from datasets import load_dataset
import numpy as np
from vllm import LLM, SamplingParams
import random

instruct_prompt = r"You FIRST think about the reasoning process as an internal monologue and then provide the final answer. The reasoning process MUST BE enclosed within <think> </think> tags. The final answer MUST BE put in \boxed{}."

def dump_to_jsonl(obj: list[dict], path: str):
    with open(path, 'w') as file:
        file.writelines([json.dumps(x) + '\n' for x in obj])

def split_list(lst, n):
    """Split a list into n (roughly) equal-sized chunks"""
    chunk_size = math.ceil(len(lst) / n)  # integer division
    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)]

def get_chunk(lst, n, k):
    chunk_size = math.ceil(len(lst) / n)
    return [lst[i] for i in range(k*chunk_size, np.min([(k+1)*chunk_size, len(lst)]), 1)]

def make_conv_rm(data_obj):
    random_number = random.choice([0, 1])
    if random_number == 0:
        answers = [data_obj["response"][0], data_obj["response"][1]]
    else:
        answers = [data_obj["response"][1], data_obj["response"][0]]
    prompt_template = (
        "You are a highly skilled and impartial evaluator tasked with comparing two responses generated by a Large Multimodal Model for a given question. "
        "- Start with a thorough, side-by-side comparative analysis enclosed within <think> and </think> tags. A tie is not permitted; you must choose a better option.\n\n"
        "- Conclude with a single numeric choice enclosed within <answer> and </answer> tags:\n"
        "  - Output \"1\" if Response 1 is better.\n"
        "  - Output \"2\" if Response 2 is better.\n\n"
        "###### **Input:**  \n"
        "###### [Question]:\n{question}  \n\n"
        "###### [Response 1]:\n{answer1}  \n\n"
        "###### [Response 2]:\n{answer2}  \n\n"
        "###### **Output Format (strictly follow):**  \n"
        "<think>Your detailed comparative analysis goes here</think><answer>1/2</answer>"
    )
    formatted_prompt = prompt_template.format(question=data_obj["query"], answer1=answers[0], answer2=answers[1])
    return formatted_prompt, random_number

def prompt(data_obj):
    random_number = random.choice([0, 1])
    if random_number == 0:
        answers = [data_obj["response"][0], data_obj["response"][1]]
    else:
        answers = [data_obj["response"][1], data_obj["response"][0]]
    prompt_str = f''' You are a highly capable multimodal AI assistant tasked with evaluating answers to visual questions. Please analyze the following image and question, then determine which of the two provided answers is better.

Question: {data_obj["query"]}

Answer 1: {answers[0]}

Answer 2: {answers[1]}

Please evaluate both answers based on the following criteria:
1. Accuracy: How well does the answer align with the visual information in the image?
2. Completeness: Does the answer fully address all aspects of the question?
3. Clarity: Is the answer easy to understand and well-articulated?
4. Relevance: Does the answer directly relate to the question and the image?

After your evaluation, please:
1. Explain your reasoning for each criterion.
2. Provide an overall judgment on which answer is better (Answer 1 or Answer 2). For example: Overall Judgment: Answer X is better.

Your response should be structured and detailed, demonstrating your understanding of both the visual and textual elements of the task.'''
    return prompt_str, random_number

def eval_model(args):

    model = LLM(
        model=args.model_id,
        limit_mm_per_prompt={"image": 10, "video": 10},
        tensor_parallel_size=8,
        disable_mm_preprocessor_cache=True,
        gpu_memory_utilization=0.70, 
        max_num_seqs=4,              
        max_num_batched_tokens=8192, 
        max_model_len=8192,   
    )
    processor = AutoProcessor.from_pretrained(args.model_id)

    sampling_params = SamplingParams(
        temperature=0,
        max_tokens=args.max_tokens
    )

    questions = list(load_dataset("MMInstruction/VL-RewardBench")['test'])
    answers_file = os.path.expanduser(args.answers_file)
    os.makedirs(os.path.dirname(answers_file), exist_ok=True)

    final_response = []
    batch_size = args.batch_size
    for chunk in tqdm(split_list(questions, math.ceil(len(questions) / batch_size))):
        batch_inputs = []
        for data in chunk:
            img = data['image']
            if img.height < 28 or img.width < 28:
                print('Skip sample')
                continue

            if args.model_id == 'yifanzhang114/R1-Reward':
                question, number = make_conv_rm(data)
            else:
                question, number = prompt(data)
                if args.is_thinking:
                    question = question + instruct_prompt
            data['random_number'] = number

            message = [
                {"role": "system", "content": "You are a helpful assistant."},
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "min_pixels": 224 * 224,
                            "max_pixels": 1280 * 28 * 28,
                        },
                        {"type": "text", "text": question},
                    ],
                },
            ]
            text = processor.apply_chat_template(
                message,
                tokenize=False,
                add_generation_prompt=True,
            )

            if args.is_mimo_thinking:
                text += "<think>"

            batch_inputs.append({"prompt": text, "multi_modal_data": {"image": img}})

        outputs = model.generate(batch_inputs, sampling_params=sampling_params, use_tqdm=False)
        for out, data in zip(outputs, chunk):
            data['vlm_response'] = out.outputs[0].text
            data['image'] = []
            final_response.append(data)

    dump_to_jsonl(final_response, args.answers_file)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--model_id", type=str, default=None)
    parser.add_argument("--answers-file", type=str, default=None)
    parser.add_argument("--batch-size", type=int, default=1)
    parser.add_argument("--max-tokens", type=int, default=4096, help="Maximum new tokens to generate")
    parser.add_argument("--is-thinking", action="store_true", help="Append the thinking prompt to the question (disabled for R1-Reward)")
    parser.add_argument("--is-mimo-thinking", action="store_true", help="Append an explicit <think> tag after the chat template")
    args = parser.parse_args()

    eval_model(args)
